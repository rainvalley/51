C51 COMPILER V9.60.0.0   MAIN                                                              08/12/2020 12:19:29 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include<stc15f2k60s2.h>
   2          #include"iic.h"
   3          #include<intrins.h>
   4          typedef unsigned char uchar;
   5          typedef unsigned int uint;
   6          uchar code dig_code[]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0xbf,0xff};
   7          uchar keystat[4]={1,1,1,1};
   8          uchar keybackup[4]={1,1,1,1};
   9          uchar time[4]={4,4,4,4};
  10          uchar volta=0,flag_800ms=0,mode=0,select_mode=1,pwm=25,stat=0,data_led=0;
  11          sbit S4 = P3^3;
  12          sbit S5 = P3^2;
  13          sbit S6 = P3^1;
  14          sbit S7 = P3^0;
  15          void set_pwm();
  16          void select(uchar channel)
  17          {
  18   1        switch(channel)
  19   1        {
  20   2          case 4:
  21   2            P2=(P2&0x1f)|0x80;
  22   2            break;
  23   2          case 5:
  24   2            P2=(P2&0x1f)|0xa0;
  25   2            break;
  26   2          case 6:
  27   2            P2=(P2&0x1f)|0xc0;
  28   2            break;
  29   2          case 7:
  30   2            P2=(P2&0x1f)|0xe0;
  31   2            break;
  32   2          default:
  33   2            P2=(P2&0x1f);
  34   2            break;
  35   2        }
  36   1      }
  37          
  38          void init_sys()
  39          {
  40   1        select(4);
  41   1        P0=0xff;
  42   1        select(5);
  43   1        P0=0x00;
  44   1        select(0);
  45   1      }
  46          
  47          void delay(uint t)
  48          {
  49   1        while(t--);
  50   1      }
  51          
  52          void display(uchar pos,uchar num)
  53          {
  54   1        delay(1500);
C51 COMPILER V9.60.0.0   MAIN                                                              08/12/2020 12:19:29 PAGE 2   

  55   1        P0=0xff;
  56   1        select(6);
  57   1        P0=0x01<<pos;
  58   1        select(7);
  59   1        P0=dig_code[num];
  60   1      }
  61          
  62          uchar read_pcf8591(uchar ain)
  63          {
  64   1        uchar volta;
  65   1        IIC_Start();
  66   1        IIC_SendByte(0x90);
  67   1        IIC_WaitAck();
  68   1        IIC_SendByte(ain);
  69   1        IIC_WaitAck();
  70   1        IIC_Stop();
  71   1        
  72   1        IIC_Start();
  73   1        IIC_SendByte(0x91);
  74   1        IIC_WaitAck();
  75   1        volta=IIC_RecByte();
  76   1        IIC_Ack(0);
  77   1        IIC_Stop();
  78   1        
  79   1        return volta;
  80   1      }
  81          
  82          void write_at24c02(uchar address,uchar dat)
  83          {
  84   1        IIC_Start();
  85   1        IIC_SendByte(0xa0);
  86   1        IIC_WaitAck();
  87   1        IIC_SendByte(address);
  88   1        IIC_WaitAck();
  89   1        IIC_SendByte(dat);
  90   1        IIC_WaitAck();
  91   1        IIC_Stop();
  92   1      }
  93          
  94          uchar read_at24c02(uchar address)
  95          {
  96   1        uchar dat;
  97   1        IIC_Start();
  98   1        IIC_SendByte(0xa0);
  99   1        IIC_WaitAck();
 100   1        IIC_SendByte(address);
 101   1        IIC_WaitAck();
 102   1        IIC_Stop();
 103   1        
 104   1        IIC_Start();
 105   1        IIC_SendByte(0xa1);
 106   1        IIC_WaitAck();
 107   1        dat=IIC_RecByte();
 108   1        IIC_Ack(0);
 109   1        IIC_Stop();
 110   1        
 111   1        return dat;
 112   1      }
 113          
 114          
 115          void scan_key()
 116          {
C51 COMPILER V9.60.0.0   MAIN                                                              08/12/2020 12:19:29 PAGE 3   

 117   1        uchar i;
 118   1        static uchar keybuff[4]={0xff,0xff,0xff,0xff};
 119   1        keybuff[0]=(keybuff[0]<<1)|S4;
 120   1        keybuff[1]=(keybuff[1]<<1)|S5;
 121   1        keybuff[2]=(keybuff[2]<<1)|S6;
 122   1        keybuff[3]=(keybuff[3]<<1)|S7;
 123   1        for(i=0;i<4;i++)
 124   1        {
 125   2          if(keybuff[i]==0xff)
 126   2          {
 127   3            keystat[i]=1;
 128   3          }
 129   2          if(keybuff[i]==0x00)
 130   2          {
 131   3            keystat[i]=0;
 132   3          }
 133   2        }
 134   1      }
 135          
 136          
 137          void init_timer0(void)    //1毫秒@11.0592MHz
 138          {
 139   1        AUXR |= 0x80;   //定时器时钟1T模式
 140   1        TMOD &= 0xF0;   //设置定时器模式
 141   1        TL0 = 0xCD;   //设置定时初值
 142   1        TH0 = 0xD4;   //设置定时初值
 143   1        TF0 = 0;    //清除TF0标志
 144   1        TR0 = 1;    //定时器0开始计时
 145   1        ET0 = 1;
 146   1        EA = 1;
 147   1      }
 148          
 149          void ser_timer0() interrupt 1
 150          {
 151   1        static uchar update_count=0;
 152   1        static uint display_count=0;
 153   1        display_count++;
 154   1        update_count++;
 155   1        scan_key(); //每1ms扫描一次键盘
 156   1        if(display_count==800) //每800ms闪烁一次数码管
 157   1        {
 158   2          flag_800ms=~flag_800ms;
 159   2          display_count=0;
 160   2        }
 161   1        if(update_count==100) //每50ms更新一次at24c02与pcf8591
 162   1        {
 163   2          volta=read_pcf8591(3);
 164   2      //    write_at24c02(0x00,time[0]);
 165   2      //    write_at24c02(0x01,time[1]);
 166   2      //    write_at24c02(0x02,time[2]);
 167   2      //    write_at24c02(0x03,time[3]);
 168   2          update_count=0;
 169   2          set_pwm(); //每10ms更新一次pwm占空比
 170   2        }
 171   1      }
 172          
 173          void key_fun(uchar key)
 174          {
 175   1        if(key==3) //停止TR1的计数
 176   1        {
 177   2          if(TR1==0)
 178   2          {
C51 COMPILER V9.60.0.0   MAIN                                                              08/12/2020 12:19:29 PAGE 4   

 179   3            TR1=1;
 180   3          }
 181   2          else
 182   2          {
 183   3            TR1=0;
 184   3          }
 185   2            
 186   2        }
 187   1        if(key==2) //改变数码管工作模式：0――熄灭，1――运行模式，2――流转间隔
 188   1        {
 189   2          mode++;
 190   2          if(mode==3)
 191   2          {
 192   3            mode=0;
 193   3          }
 194   2        }
 195   1        if(key==1&&mode==1) //增加运行模式
 196   1        {
 197   2          select_mode++;
 198   2          if(select_mode==5)
 199   2          {
 200   3            select_mode=1;
 201   3          }
 202   2        }
 203   1        if(key==0&&mode==1) //减少运行模式
 204   1        {
 205   2          select_mode--;
 206   2          if(select_mode==0)
 207   2          {
 208   3            select_mode=4;
 209   3          }
 210   2        }
 211   1        
 212   1        if(key==1&&mode==2) //增加流转间隔
 213   1        {
 214   2          time[select_mode-1]++;
 215   2          if(time[select_mode-1]==13)
 216   2          {
 217   3            time[select_mode-1]=4;
 218   3          }
 219   2        }
 220   1        if(key==0&&mode==2) //减少流转间隔
 221   1        {
 222   2          time[select_mode-1]--;
 223   2          if(time[select_mode-1]==3)
 224   2          {
 225   3            time[select_mode-1]=12;
 226   3          }
 227   2        }
 228   1      }
 229          
 230          void key_press()
 231          {
 232   1        int i;
 233   1        for(i=0;i<4;i++)
 234   1        {
 235   2          if(keystat[i]!=keybackup[i])
 236   2          {
 237   3            if(keybackup[i]!=0)
 238   3            {
 239   4              key_fun(i);
 240   4            }
C51 COMPILER V9.60.0.0   MAIN                                                              08/12/2020 12:19:29 PAGE 5   

 241   3            keybackup[i]=keystat[i];
 242   3          }
 243   2        }
 244   1      }
 245          
 246          void display_data()
 247          {
 248   1        if(mode==0) //如果数码管处于熄灭状态，长按显示亮度状态
 249   1        {
 250   2          if(keystat[0]==0&&mode==0)
 251   2          {
 252   3            while(keystat[0]==0)
 253   3            {
 254   4              display(6,10);
 255   4              display(7,pwm/25);
 256   4            }
 257   3          }
 258   2          else
 259   2          {
 260   3            select(6);
 261   3            P0=0xff;
 262   3            select(7);
 263   3            P0=0xff;
 264   3          }
 265   2        }
 266   1        if(mode==1) //如果选中运行模式
 267   1        {
 268   2          if(flag_800ms) //800ms闪烁数码管
 269   2          {
 270   3            display(0,10);
 271   3            display(1,select_mode);
 272   3            display(2,10);
 273   3          }
 274   2          else
 275   2          {
 276   3            display(0,11);
 277   3            display(1,11);
 278   3            display(2,11);
 279   3          }
 280   2          if(time[select_mode-1]>=10) //流转间隔>=1000时显示第四位
 281   2          {
 282   3            display(4,time[select_mode-1]/10);
 283   3            display(5,time[select_mode-1]%10);
 284   3          }
 285   2          else
 286   2          {
 287   3            display(5,time[select_mode-1]);
 288   3          }
 289   2          display(6,0);
 290   2          display(7,0);
 291   2        }
 292   1        if(mode==2) //如果选中流转间隔
 293   1        {
 294   2          display(0,10);
 295   2          display(1,select_mode);
 296   2          display(2,10);
 297   2          if(flag_800ms) //800ms数码管闪烁间隔
 298   2          {
 299   3            if(time[select_mode-1]>=10) //如果流转间隔>=1000则显示第四位
 300   3            {
 301   4              display(4,time[select_mode-1]/10);
 302   4              display(5,time[select_mode-1]%10);
C51 COMPILER V9.60.0.0   MAIN                                                              08/12/2020 12:19:29 PAGE 6   

 303   4            }
 304   3            else
 305   3            {
 306   4              display(5,time[select_mode-1]);
 307   4            }
 308   3            display(6,0);
 309   3            display(7,0);
 310   3          }
 311   2          else
 312   2          {
 313   3            display(4,11);
 314   3            display(5,11);
 315   3            display(6,11);
 316   3            display(7,11);
 317   3          }
 318   2        }
 319   1      }
 320          
 321          void set_pwm()
 322          {
 323   1        uchar dat;
 324   1        dat=read_pcf8591(3);
 325   1        if(dat<=64)
 326   1        {
 327   2          pwm=25;
 328   2        }
 329   1        else if(dat<=128)
 330   1        {
 331   2          pwm=50;
 332   2        } 
 333   1        else if(dat<=192)
 334   1        {
 335   2          pwm=75;
 336   2        }
 337   1        else
 338   1        {
 339   2          pwm=100;
 340   2        }
 341   1      }
 342          
 343          void init_timer1(void)    //100微秒@11.0592MHz
 344          {
 345   1        AUXR |= 0x40;   //定时器时钟1T模式
 346   1        TMOD &= 0x0F;   //设置定时器模式
 347   1        TL1 = 0xAE;   //设置定时初值
 348   1        TH1 = 0xFB;   //设置定时初值
 349   1        TF1 = 0;    //清除TF1标志
 350   1        TR1 = 1;    //定时器1开始计时
 351   1        ET1 = 1;
 352   1        EA = 1;
 353   1      }
 354          
 355          void led_run()
 356          {
 357   1        switch(stat)
 358   1        {
 359   2          case 0:
 360   2            data_led=0xff;
 361   2            break;
 362   2          case 1:
 363   2            data_led=0xfe;
 364   2            break;
C51 COMPILER V9.60.0.0   MAIN                                                              08/12/2020 12:19:29 PAGE 7   

 365   2          case 2:
 366   2            data_led=0xfc;
 367   2            break;
 368   2          case 3:
 369   2            data_led=0xf8;
 370   2            break;
 371   2          case 4:
 372   2            data_led=0xf0;
 373   2            break;
 374   2          case 5:
 375   2            data_led=0xe0;
 376   2            break;
 377   2          case 6:
 378   2            data_led=0xc0;
 379   2            break;
 380   2          case 7:
 381   2            data_led=0x80;
 382   2            break;
 383   2          case 8:
 384   2            data_led=0x00;
 385   2            break;
 386   2          case 9:
 387   2            data_led=0x7f;
 388   2            break;
 389   2          case 10:
 390   2            data_led=0x3f;
 391   2            break;
 392   2          case 11:
 393   2            data_led=0x1f;
 394   2            break;
 395   2          case 12:
 396   2            data_led=0x0f;
 397   2            break;
 398   2          case 13:
 399   2            data_led=0x07;
 400   2            break;
 401   2          case 14:
 402   2            data_led=0x03;
 403   2            break;
 404   2          case 15:
 405   2            data_led=0x01;
 406   2            break;
 407   2          case 16:
 408   2            data_led=0x00;
 409   2            break;
 410   2          case 17:
 411   2            data_led=0x7e;
 412   2            break;
 413   2          case 18:
 414   2            data_led=0xbd;
 415   2            break;
 416   2          case 19:
 417   2            data_led=0xdb;
 418   2            break;
 419   2          case 20:
 420   2            data_led=0xe7;
 421   2            break;
 422   2          case 21:
 423   2            data_led=0xe7;
 424   2            break;
 425   2          case 22:
 426   2            data_led=0xdb;
C51 COMPILER V9.60.0.0   MAIN                                                              08/12/2020 12:19:29 PAGE 8   

 427   2            break;
 428   2          case 23:
 429   2            data_led=0xbd;
 430   2            break;
 431   2          case 24:
 432   2            data_led=0x7e;
 433   2            break;
 434   2        }
 435   1      }
 436          
 437          void ser_timer1() interrupt 3
 438          {
 439   1        static uint count=0,pwm_count=0;
 440   1        static uchar temp_mode=1;
 441   1        count++;
 442   1        pwm_count++;
 443   1        if(count==time[temp_mode-1]*1000)
 444   1        {
 445   2          count=0;
 446   2          led_run();
 447   2          if(stat==24)
 448   2          {
 449   3            stat=0;
 450   3          }
 451   2          stat++;
 452   2          if(stat==0)
 453   2          {
 454   3            temp_mode=1;
 455   3          }
 456   2          else if(stat==9)
 457   2          {
 458   3            temp_mode=2;
 459   3          }
 460   2          else if(stat==17)
 461   2          {
 462   3            temp_mode=3;
 463   3          }
 464   2          else if(stat==21)
 465   2          {
 466   3            temp_mode=4;
 467   3          }
 468   2        }
 469   1        select(4);
 470   1        P0=data_led;
 471   1      //  if(pwm_count<=pwm)
 472   1      //  {
 473   1      //    select(4);
 474   1      //    P0=data_led;
 475   1      //    select(0);
 476   1      //  }
 477   1      //  else if(pwm_count<100)
 478   1      //  {
 479   1      //    select(4);
 480   1      //    P0=0xff;
 481   1      //    select(0);
 482   1      //  }
 483   1      //  else if(pwm_count==100)
 484   1      //  {
 485   1      //    pwm_count=0;
 486   1      //  }
 487   1      }
 488          
C51 COMPILER V9.60.0.0   MAIN                                                              08/12/2020 12:19:29 PAGE 9   

 489          int main()
 490          {
 491   1        init_sys();
 492   1        init_timer0();
 493   1        init_timer1();
 494   1        while(1)
 495   1        {
 496   2          key_press();
 497   2          display_data();
 498   2        }
 499   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1365    ----
   CONSTANT SIZE    =     12    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     31       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
