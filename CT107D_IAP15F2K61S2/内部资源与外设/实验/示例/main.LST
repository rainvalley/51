C51 COMPILER V9.60.0.0   MAIN                                                              08/07/2020 17:56:17 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include<reg52.h>
   2          #include"onewire.h"
   3          #include"ds1302.h"
   4          #include"data.h"
   5          #include"iic.h"
   6          #include"intrins.h"
   7          void Display_Dynamic();
   8          uchar code dig_code[10]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};//数码管显示内容
   9          uchar time[7]={0x50,0x59,0x23,0x01,0x01,0x01,0x20};//DS1302初始化内容
  10          uint temp=0;
  11          int data_pcf8591=0;
  12          uint data_at24c02=0;
  13          uint distance=0;
  14          sbit TX=P1^0;
  15          sbit RX=P1^1;
  16          uint j;
  17          uint count_times=0;
  18          uint count_time=0;
  19          uint frequency=0;
  20          //延时函数
  21          void Delay(uint t)
  22          {
  23   1        while(t--);
  24   1      }
  25          
  26          //选择138译码器输出端
  27          void selectHC573(uchar channel)
  28          {
  29   1        switch(channel)
  30   1        {
  31   2          case 4:
  32   2          P2=(P2&0x1f)|0x80;//不改变P2其他端口电平的情况下改变138译码器输入，由于前移一位故channel*2。
  33   2          break;
  34   2          case 5:
  35   2          P2=(P2&0x1f)|0xa0;
  36   2          break;
  37   2          case 6:
  38   2          P2=(P2&0x1f)|0xc0;
  39   2          break;
  40   2          case 7:
  41   2          P2=(P2&0x1f)|0xe0;
  42   2        }
  43   1      }
  44          
  45          //按位点亮数码管
  46          void DisplaySMG_Bit(uchar value,uchar pos)
  47          { 
  48   1        P0=0XFF;
  49   1        selectHC573(6);
  50   1        P0=0X01<<pos;//channel选择为6时选择数码管位置
  51   1        selectHC573(7);
  52   1        P0=dig_code[value];//channel选择为7时选择数码管显示内容
  53   1      }
  54          
  55          //获取温度
C51 COMPILER V9.60.0.0   MAIN                                                              08/07/2020 17:56:17 PAGE 2   

  56          void tempget()
  57          {
  58   1        uchar low,high;
  59   1        EA=0;
  60   1        init_ds18b20();
  61   1        Write_DS18B20(0XCC);
  62   1        Write_DS18B20(0X44);
  63   1      
  64   1        init_ds18b20();
  65   1        Write_DS18B20(0XCC);
  66   1        Write_DS18B20(0Xbe);
  67   1      /*
  68   1      DS18B20操作步骤(P11)：
  69   1      1-初始化
  70   1      2-跳过ROM
  71   1      3-转换温度(0x44)/开始读取温度Scratchpad(0xbe)
  72   1      */
  73   1      
  74   1        low=Read_DS18B20();
  75   1        high=Read_DS18B20();
  76   1      
  77   1        temp=high<<4;
  78   1        temp|=(low>>4);//将DS18B20数据转换为十进制并截取整数部分
  79   1        EA=1;
  80   1      } 
  81          
  82          //动态显示温度
  83          void Display_Dynmaic_temp()
  84          {
  85   1        tempget();
  86   1        DisplaySMG_Bit(temp%100/10,5);
  87   1        Delay(500);
  88   1        P0=0XFF;
  89   1        DisplaySMG_Bit(temp%10,6);
  90   1        Delay(500);
  91   1        P0=0XFF;
  92   1        //显示温度整数部分
  93   1        selectHC573(6);
  94   1        P0=0X01<<7;
  95   1        selectHC573(7);
  96   1        P0=0XC6;//显示C代表摄氏度
  97   1      }
  98                              
  99          //DS1302初始化
 100          
 101          void ds1302_init()
 102          {
 103   1        uchar add=0x80;//写数据地址
 104   1        uchar i;
 105   1        Write_Ds1302_Byte(0x8e,0x00); //关闭写保护
 106   1        for(i=0;i<7;i++)
 107   1        {
 108   2          Write_Ds1302_Byte(add,time[i]);
 109   2          add=add+2;
 110   2        }
 111   1        Write_Ds1302_Byte(0x8e,0x80); //开启写保护
 112   1      }
 113          
 114          //读取DS1302时间，地址可见P9，WP位为写保护控制位
 115          void ds1302_read()
 116          {
 117   1        uchar i;
C51 COMPILER V9.60.0.0   MAIN                                                              08/07/2020 17:56:17 PAGE 3   

 118   1        uchar add=0x81;//读数据地址
 119   1        Write_Ds1302_Byte(0x8e,0x00);//关闭写保护
 120   1        for(i=0;i<7;i++)
 121   1        {
 122   2          time[i]=Read_Ds1302_Byte(add);
 123   2          add=add+2;
 124   2        }
 125   1        Write_Ds1302_Byte(0x8e,0x80);//开启写保护
 126   1      }
 127          
 128          //动态显示时间
 129          void Display_Dynmaic_time()
 130          {
 131   1        ds1302_read();
 132   1        DisplaySMG_Bit(time[1]/16,0); //BCD码取十位
 133   1        Delay(500);
 134   1        P0=0XFF;
 135   1        DisplaySMG_Bit(time[1]%16,1);//BCD码取个位
 136   1        Delay(500);
 137   1        P0=0XFF; //以上是分钟的显示
 138   1        selectHC573(6);
 139   1        P0=0X01<<2;
 140   1        selectHC573(7);
 141   1        P0=~0X40;
 142   1        Delay(500);
 143   1        P0=0XFF; //以上是分隔符显示
 144   1        DisplaySMG_Bit(time[0]/16,3);
 145   1        Delay(500);
 146   1        P0=0XFF;
 147   1        DisplaySMG_Bit(time[0]%16,4); //以上是秒的显示
 148   1      }
 149          
 150          //从A/D通道3读取数据
 151          void Read_AIN3()
 152          {
 153   1        IIC_Start();    //IIC总线起始信号             
 154   1        IIC_SendByte(0x90);   //PCF8591的写设备地址   
 155   1        IIC_WaitAck();    //等待从机应答
 156   1            
 157   1        IIC_SendByte(0x01);   //写入PCF8591的控制字节   
 158   1        IIC_WaitAck();    //等待从机应答            
 159   1        IIC_Stop();     //IIC总线停止信号         
 160   1        
 161   1      
 162   1      
 163   1        IIC_Start();                      
 164   1        IIC_SendByte(0x91);     
 165   1        IIC_WaitAck();
 166   1                
 167   1        data_pcf8591 = IIC_RecByte();     
 168   1        IIC_SendAck(1);     //产生非应答信号        
 169   1        IIC_Stop();     //IIC总线停止信号         
 170   1      }
 171          
 172          
 173          void Display_Dynmaic_pcf8591()
 174          {
 175   1        Read_AIN3();
 176   1          DisplaySMG_Bit(data_pcf8591/100,0);
 177   1        Delay(500);
 178   1        DisplaySMG_Bit((data_pcf8591%100)/10,1);
 179   1        Delay(500);
C51 COMPILER V9.60.0.0   MAIN                                                              08/07/2020 17:56:17 PAGE 4   

 180   1        DisplaySMG_Bit(data_pcf8591%10,2);
 181   1        Delay(500);
 182   1      }
 183          
 184          void write_at24c02(uchar addr,uint data_at24c02)
 185          {
 186   1        IIC_Start();
 187   1        IIC_SendByte(0XA0);
 188   1        IIC_WaitAck();
 189   1        IIC_SendByte(addr);
 190   1        IIC_WaitAck();
 191   1        IIC_SendByte(data_at24c02);
 192   1        IIC_WaitAck();
 193   1        IIC_Stop();
 194   1      }
 195          
 196          uint read_at24c02(uchar addr)
 197          {
 198   1        uchar tmp_at24c02;
 199   1        IIC_Start();
 200   1        IIC_SendByte(0XA0);
 201   1        IIC_WaitAck();
 202   1        IIC_SendByte(addr);
 203   1        IIC_WaitAck();
 204   1      
 205   1        IIC_Start();
 206   1        IIC_SendByte(0XA1);
 207   1        IIC_WaitAck();
 208   1        tmp_at24c02=IIC_RecByte();
 209   1        IIC_SendAck(1);
 210   1        IIC_Stop();
 211   1        return tmp_at24c02;
 212   1      }
 213          
 214          void Display_Dynmaic_at24c02()
 215          { 
 216   1        write_at24c02(0X01,0x0f);
 217   1        data_at24c02=read_at24c02(0x01);
 218   1        DisplaySMG_Bit(data_at24c02/100,0);
 219   1        Delay(500);
 220   1        DisplaySMG_Bit(data_at24c02%100/10,1);
 221   1        Delay(500);
 222   1        DisplaySMG_Bit(data_at24c02%10,2);
 223   1        Delay(500);
 224   1        
 225   1      }
 226          
 227          void Delay12us()    //@12.000MHz
 228          {
 229   1        unsigned char i;
 230   1      
 231   1        _nop_();
 232   1        _nop_();
 233   1        i = 33;
 234   1        while (--i);
 235   1      }
 236          
 237          void send_wave()
 238          {
 239   1        uchar i;
 240   1        for(i=0;i<8;i++)
 241   1        {
C51 COMPILER V9.60.0.0   MAIN                                                              08/07/2020 17:56:17 PAGE 5   

 242   2          TX=1;
 243   2          Delay12us();
 244   2          TX=0;
 245   2          Delay12us();
 246   2        }
 247   1      }
 248          
 249          void measure_distance()
 250          {
 251   1        uint time_sonic=0;
 252   1        TMOD&=0X0F;
 253   1        TL1=0X00;
 254   1        TH1=0X00;
 255   1      
 256   1        send_wave();
 257   1        TR1=1;
 258   1        while((RX==1)&&(TF1==0));
 259   1        TR1=0;
 260   1      
 261   1        if(TF1==0)
 262   1        {
 263   2          time_sonic=TH1;
 264   2          time_sonic=(time_sonic<<8)|TL1;
 265   2          distance=((time_sonic/10)*17)/100+3;
 266   2        }
 267   1        else
 268   1        {
 269   2          TF1=0;
 270   2          distance=999;
 271   2        }
 272   1      }
 273          
 274          void Display_Dynmaic_sonic()
 275          {
 276   1        measure_distance();
 277   1        for(j=0;j<100;j++)
 278   1        {
 279   2          DisplaySMG_Bit(distance/100,0);
 280   2          Delay(500);
 281   2          DisplaySMG_Bit(distance%100/10,1);
 282   2          Delay(500);
 283   2          DisplaySMG_Bit(distance%10,2);
 284   2          Delay(500);
 285   2        }
 286   1        
 287   1      }
 288          
 289          void init_timer()
 290          {
 291   1        TH0=0XFF;
 292   1        TL0=0XFF;
 293   1        TH1=(65536-50000)/256;
 294   1        TL1=(65536-50000)%256;
 295   1      
 296   1        TMOD=0X16;
 297   1      
 298   1        ET1=1;
 299   1        ET0=1;
 300   1        EA=1;
 301   1        TR0=1;
 302   1        TR1=1;
 303   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              08/07/2020 17:56:17 PAGE 6   

 304          
 305          void t0_service() interrupt 1
 306          {
 307   1        count_times++;
 308   1      }
 309          
 310          void t1_service() interrupt 3
 311          {
 312   1        TH1=(65536-50000)/256;
 313   1        TL1=(65536-50000)%256;
 314   1        count_time++;
 315   1        if(count_time==20)
 316   1        {      
 317   2          frequency=count_times;
 318   2          count_times=0;
 319   2          count_time=0;
 320   2        }
 321   1      }
 322          
 323          void Display_Dynmaic_ne555()
 324          {
 325   1        DisplaySMG_Bit(frequency/10000,3);
 326   1        Delay(500);
 327   1        DisplaySMG_Bit(frequency/1000%10,4);
 328   1        Delay(500);
 329   1        DisplaySMG_Bit(frequency/100%10,5);
 330   1        Delay(500);
 331   1        DisplaySMG_Bit(frequency/10%10,6);
 332   1        Delay(500);
 333   1        DisplaySMG_Bit(frequency%10,7);
 334   1        Delay(500);
 335   1      }
 336          
 337          int main()
 338          {
 339   1        selectHC573(5);
 340   1        P0=0X00;//初始化板上资源，关闭蜂鸣器与继电器
 341   1        selectHC573(7);
 342   1        ds1302_init();
 343   1        init_timer();
 344   1        while(1)
 345   1        { 
 346   2          //Display_Dynmaic_temp();
 347   2          Display_Dynmaic_time();
 348   2          //Display_Dynmaic_pcf8591();
 349   2          //Display_Dynmaic_at24c02();
 350   2          //Display_Dynmaic_sonic();
 351   2          //Display_Dynmaic_ne555();
 352   2        }
 353   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1084    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
